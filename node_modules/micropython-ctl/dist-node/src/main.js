"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MicroPythonDevice = exports.RawReplState = exports.ReplMode = exports.ConnectionState = exports.ConnectionMode = exports.WEBSERVER_PORT = exports.ScriptExecutionError = exports.CouldNotConnect = exports.InvalidPassword = void 0;
/**
 * Async TypeScript MicroPython interface (for serial and network connections, REPL & WebREPL)
 *
 * - License: MIT
 * - Repository: https://github.com/metachris/micropython-ctl
 * - Author: chris@linuxuser.at / https://twitter.com/metachris
 */
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const buffer_1 = require("buffer/");
const errors_1 = require("./errors");
Object.defineProperty(exports, "InvalidPassword", { enumerable: true, get: function () { return errors_1.InvalidPassword; } });
Object.defineProperty(exports, "CouldNotConnect", { enumerable: true, get: function () { return errors_1.CouldNotConnect; } });
Object.defineProperty(exports, "ScriptExecutionError", { enumerable: true, get: function () { return errors_1.ScriptExecutionError; } });
const utils_1 = require("./utils");
const PythonScripts = __importStar(require("./python-scripts"));
const settings_1 = require("./settings");
Object.defineProperty(exports, "WEBSERVER_PORT", { enumerable: true, get: function () { return settings_1.WEBSERVER_PORT; } });
// Importing the following modules only if possible (won't be if run in browser)
let fetch;
let webserver;
try {
    // tslint:disable-next-line: no-var-requires
    fetch = require('node-fetch');
    // tslint:disable-next-line: no-var-requires
    webserver = require('./webserver');
    // tslint:disable-next-line: no-empty
}
catch (_a) { }
const delayMillis = (delayMs) => new Promise(resolve => setTimeout(resolve, delayMs));
var ConnectionMode;
(function (ConnectionMode) {
    ConnectionMode["SERIAL"] = "SERIAL";
    ConnectionMode["NETWORK"] = "NETWORK";
    ConnectionMode["PROXY"] = "PROXY";
})(ConnectionMode = exports.ConnectionMode || (exports.ConnectionMode = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState["CONNECTING"] = "CONNECTING";
    ConnectionState["OPEN"] = "OPEN";
    ConnectionState["CLOSED"] = "CLOSED";
})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
var ReplMode;
(function (ReplMode) {
    ReplMode["TERMINAL"] = "TERMINAL";
    ReplMode["SCRIPT_RAW_MODE"] = "SCRIPT_RAW_MODE";
    ReplMode["GETVER_WAITING_RESPONSE"] = "GETVER_WAITING_RESPONSE";
    ReplMode["PUTFILE_WAITING_FIRST_RESPONSE"] = "PUTFILE_WAITING_FIRST_RESPONSE";
    ReplMode["PUTFILE_WAITING_FINAL_RESPONSE"] = "PUTFILE_WAITING_FINAL_RESPONSE";
})(ReplMode = exports.ReplMode || (exports.ReplMode = {}));
var RawReplState;
(function (RawReplState) {
    RawReplState["WAITING_FOR_SCRIPT"] = "WAITING_FOR_SCRIPT";
    RawReplState["SCRIPT_SENT"] = "SCRIPT_SENT";
    RawReplState["SCRIPT_RECEIVING_RESPONSE"] = "SCRIPT_RECEIVING_RESPONSE";
    RawReplState["SCRIPT_EXECUTED"] = "SCRIPT_EXECUTED";
})(RawReplState = exports.RawReplState || (exports.RawReplState = {}));
var RawReplReceivingResponseSubState;
(function (RawReplReceivingResponseSubState) {
    RawReplReceivingResponseSubState["SCRIPT_RECEIVING_OUTPUT"] = "SCRIPT_RECEIVING_OUTPUT";
    RawReplReceivingResponseSubState["SCRIPT_RECEIVING_ERROR"] = "SCRIPT_RECEIVING_ERROR";
    RawReplReceivingResponseSubState["SCRIPT_WAITING_FOR_END"] = "SCRIPT_WAITING_FOR_END";
})(RawReplReceivingResponseSubState || (RawReplReceivingResponseSubState = {}));
/**
 * Main class for a MicroPython device connection.
 *
 * See also https://github.com/metachris/micropython-ctl
 *
 * ```
 * const micropython = new MicroPythonDevice()
 *
 * // Connect to micropython device over network
 * await micropython.connectNetwork('DEVICE_IP', 'WEBREPL_PASSWORD')
 *
 * // Or connect to micropython device over serial interface
 * await micropython.connectSerial('/dev/ttyUSB0')
 *
 * // Run a Python script and capture the output
 * const output = await micropython.runScript('import os; print(os.listdir())')
 *
 * // List all files in the root
 * const files = await micropython.listFiles()
 * ```
 */
class MicroPythonDevice {
    constructor() {
        this.state = {
            connectionMode: ConnectionMode.NETWORK,
            connectionState: ConnectionState.CLOSED,
            connectionPath: null,
            port: null,
            ws: null,
            wsConnectTimeout: undefined,
            wsConnectTimeoutTriggered: false,
            replMode: ReplMode.TERMINAL,
            replPassword: '',
            lastCommand: '',
            inputBuffer: '',
            errorBuffer: '',
            broadcastCommandOutputAsTerminalData: false,
            dataRawBuffer: new buffer_1.Buffer(0),
            isReadingUntil: false,
            readUntilData: new buffer_1.Buffer(0),
            readUntilBuffer: new buffer_1.Buffer(0),
            readUntilPromise: null,
            readUntilPromiseResolve: null,
            readUntilPromiseReject: null,
            readUntilTimeout: null,
            replPromise: null,
            replPromiseResolve: null,
            replPromiseReject: null,
            rawReplState: RawReplState.WAITING_FOR_SCRIPT,
            lastRunScriptTimeNeeded: -1,
            receivingResponseSubState: RawReplReceivingResponseSubState.SCRIPT_RECEIVING_ERROR,
            putFileSize: 0,
            putFileData: new Uint8Array(),
            putFileName: '',
            putFileDest: '',
        };
    }
    /**
     * Whether currently connected to a device.
     */
    isConnected() {
        return this.state.connectionState === ConnectionState.OPEN;
    }
    isSerialDevice() {
        return this.state.connectionMode === ConnectionMode.SERIAL;
    }
    isProxyConnection() {
        return this.state.connectionMode === ConnectionMode.PROXY;
    }
    isTerminalMode() {
        return this.state.replMode === ReplMode.TERMINAL;
    }
    /**
     * Get the state object. Mostly used for debugging purposes.
     */
    getState() {
        return this.state;
    }
    createReplPromise() {
        this.state.replPromise = new Promise((resolve, reject) => {
            this.state.replPromiseResolve = resolve;
            this.state.replPromiseReject = reject;
        });
        return this.state.replPromise;
    }
    /** The internal webserver is used to proxy runScript commands over an existing connection */
    startInternalWebserver() {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.debug('startInternalWebserver...');
            if (webserver)
                webserver.run(this);
        });
    }
    connectProxy() {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.connectionMode = ConnectionMode.PROXY;
            const resp = yield fetch(`http://localhost:${settings_1.WEBSERVER_PORT}/api/`);
            if (resp.status === 200) {
                const respObj = yield resp.json();
                // console.log(respObj)
                if (respObj.deviceId === this.state.connectionPath) {
                    this.state.connectionState = ConnectionState.OPEN;
                    this.state.replMode = ReplMode.TERMINAL;
                    this.clearBuffer();
                    if (this.state.replPromiseResolve)
                        this.state.replPromiseResolve('');
                    return true;
                }
            }
            return false;
        });
    }
    /**
     * Connect to a device over the serial interface
     *
     * @param path Serial interface (eg. `/dev/ttyUSB0`, `/dev/tty.SLAB_USBtoUART`, ...)
     * @throws {CouldNotConnect} Connection failed
     */
    connectSerial(path) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.debug('connectSerial', path);
            this.state.connectionPath = `serial:${path}`;
            // Connect to serial device
            this.state.connectionMode = ConnectionMode.SERIAL;
            this.state.connectionState = ConnectionState.CONNECTING;
            this.clearBuffer();
            // Get serialport either through window.SerialPort, or require
            const SerialPort = typeof window !== 'undefined' && window.SerialPort ? window.SerialPort : require('serialport');
            // Open the serial port
            this.state.port = new SerialPort(path, { baudRate: 115200 });
            // error listener
            this.state.port.on('error', (err) => __awaiter(this, void 0, void 0, function* () {
                // On connection-error: try proxy mode (connect to REST API of an existing instance)
                if (this.state.connectionState === ConnectionState.CONNECTING && err.toString().includes('Resource temporarily unavailable')) {
                    const connectedToProxy = yield this.connectProxy();
                    if (connectedToProxy)
                        return;
                }
                if (this.state.replPromiseReject) {
                    utils_1.debug(err);
                    const e = this.state.connectionState === ConnectionState.CONNECTING ? new errors_1.CouldNotConnect(err.toString()) : err;
                    this.state.replPromiseReject(e);
                }
                else {
                    throw err;
                }
            }));
            // on-open listener
            this.state.port.on('open', () => {
                // debug('serialport onopen')
                this.state.connectionState = ConnectionState.OPEN;
                this.state.replMode = ReplMode.TERMINAL;
                this.clearBuffer();
                if (this.state.replPromiseResolve)
                    this.state.replPromiseResolve('');
            });
            // data listener
            this.state.port.on('data', (data) => {
                // debug('Data:', data, data.toString())
                this.handleProtocolData(data);
            });
            this.state.port.on('close', () => {
                this.state.connectionState = ConnectionState.CLOSED;
                if (this.onclose)
                    this.onclose();
            });
            return this.createReplPromise();
        });
    }
    /**
     * Connect to a device over the network (requires enabled WebREPL)
     *
     * @param host IP address or hostname
     * @param password webrepl password
     * @param timeoutSec Connection timeout (default: 5 sec). To disable, set to 0
     * @throws {CouldNotConnect} Connection failed
     */
    connectNetwork(host, password, timeoutSec = 5) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.connectionMode = ConnectionMode.NETWORK;
            // check if already a websocket connection active
            if (this.state.ws && this.state.ws.readyState !== isomorphic_ws_1.default.CLOSED) { // see also https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState
                console.warn("webrepl: Cannot connect, already active ws connection", this.state.ws);
                return '';
            }
            this.state.connectionPath = `ws://${host}:8266`;
            // console.log('connect', uri)
            this.state.connectionState = ConnectionState.CONNECTING;
            this.state.replPassword = password;
            this.state.ws = new isomorphic_ws_1.default(this.state.connectionPath);
            this.state.ws.binaryType = 'arraybuffer';
            // Set the connect timeout
            if (timeoutSec) {
                this.state.wsConnectTimeout = setTimeout(() => {
                    this.state.wsConnectTimeoutTriggered = true;
                    this.state.ws.close();
                }, timeoutSec * 1000);
            }
            // On connection established, clear the timeout and wait for connection data
            this.state.ws.onopen = () => {
                if (this.state.wsConnectTimeout)
                    clearTimeout(this.state.wsConnectTimeout);
            };
            // Handle messages
            this.state.ws.onmessage = (event) => this.handleWebsocketMessage(event);
            // Handle errors
            this.state.ws.onerror = (err) => __awaiter(this, void 0, void 0, function* () {
                if (this.state.wsConnectTimeoutTriggered) {
                    if (this.state.replPromiseReject)
                        this.state.replPromiseReject(new errors_1.CouldNotConnect("Connect timeout"));
                    return;
                }
                if (this.state.connectionState === ConnectionState.CONNECTING) {
                    const connectedToProxy = yield this.connectProxy();
                    if (connectedToProxy)
                        return;
                }
                const e = this.state.connectionState === ConnectionState.CONNECTING ? new errors_1.CouldNotConnect(err.message) : err;
                if (this.state.replPromiseReject)
                    this.state.replPromiseReject(e);
            });
            this.state.ws.onclose = () => {
                // console.log(`WebSocket onclose`)
                // do nothing if we try to connect to proxy
                if (this.state.connectionMode === ConnectionMode.PROXY && this.state.connectionState === ConnectionState.CONNECTING)
                    return;
                // call close handlers after a successful connection
                this.state.connectionState = ConnectionState.CLOSED;
                if (this.state.replPromiseResolve)
                    this.state.replPromiseResolve(''); // release the 'close' async event
                if (this.onclose)
                    this.onclose();
            };
            // create and return a new promise, which is fulfilled only after connecting to repl
            return this.createReplPromise();
        });
    }
    /**
     * Handle special WebREPL only commands data
     *
     * getver, putfile, getfile
     */
    handlProtocolSpecialCommandsOutput(data) {
        // helper to decode the binary data
        const decodeWebreplBinaryResponse = (_data) => {
            if (_data[0] === 'W'.charCodeAt(0) && _data[1] === 'B'.charCodeAt(0)) {
                // tslint:disable-next-line: no-bitwise
                const code = _data[2] | (_data[3] << 8);
                return code;
            }
            else {
                return -1;
            }
        };
        // HANDLE SPECIFIC SPECIAL COMMANDS (getver, putfile, getfile)
        if (this.state.replMode === ReplMode.PUTFILE_WAITING_FIRST_RESPONSE) {
            // PUTFILE
            if (decodeWebreplBinaryResponse(data) === 0) {
                // send file data in chunks
                for (let offset = 0; offset < this.state.putFileSize; offset += 1024) {
                    this.sendData(this.state.putFileData.slice(offset, offset + 1024));
                }
                this.state.replMode = ReplMode.PUTFILE_WAITING_FINAL_RESPONSE;
            }
        }
        else if (this.state.replMode === ReplMode.PUTFILE_WAITING_FINAL_RESPONSE) {
            // final response for put
            if (decodeWebreplBinaryResponse(data) === 0) {
                utils_1.debug('Upload success');
                if (this.state.replPromiseResolve)
                    this.state.replPromiseResolve('');
            }
            else {
                console.error('Upload failed');
                if (this.state.replPromiseReject)
                    this.state.replPromiseReject('Upload failed');
            }
            this.state.replMode = ReplMode.TERMINAL;
        }
        else if (this.state.replMode === ReplMode.GETVER_WAITING_RESPONSE) {
            // GETVER
            // console.log('got getver response:', data, data.toString())
            if (this.state.replPromiseResolve)
                this.state.replPromiseResolve(data.join("."));
        }
        else {
            console.log('unkown ArrayBuffer input:', data);
        }
    }
    handleWebsocketMessage(event) {
        const dataStr = event.data.toString();
        // console.log(`onWebsocketMessage`, dataStr)
        // console.log(`onWebsocketMessage:${event.data instanceof ArrayBuffer ? ' [ArrayBuffer]' : ''}${data.endsWith('\n') ? ' [End:\\n]' : ''}${data.length < 3 ? ' [char0:' + data.charCodeAt(0) + ']'  : ''}`, data.length, data)
        // On closing a ws connection there may be special final bytes (discard)
        if (this.state.ws.readyState === isomorphic_ws_1.default.CLOSING && dataStr.length === 2 && dataStr.charCodeAt(0) === 65533 && dataStr.charCodeAt(1) === 0)
            return;
        // Handle connecting: enter password and if incorrect throw InvalidPassword
        if (this.state.connectionState === ConnectionState.CONNECTING) {
            const dataTrimmed = dataStr.trim();
            if (dataTrimmed === 'Password:') {
                this.state.ws.send(this.state.replPassword + '\r');
                return;
            }
            else if (dataTrimmed === 'Access denied') {
                this.state.ws.close(); // just to be sure. micropy already closes the connection
                if (this.state.replPromiseReject)
                    this.state.replPromiseReject(new errors_1.InvalidPassword('REPL password invalid'));
                return;
            }
            else if (dataTrimmed.endsWith('\n>>>')) {
                this.state.connectionState = ConnectionState.OPEN;
                this.state.replMode = ReplMode.TERMINAL;
                this.clearBuffer();
                if (this.state.replPromiseResolve)
                    this.state.replPromiseResolve('');
            }
        }
        // If data is of type ArrayBuffer, it's a special WebREPL protocol input
        if (event.data instanceof ArrayBuffer) {
            const binData = new Uint8Array(event.data);
            this.handlProtocolSpecialCommandsOutput(binData);
            return;
        }
        // IMPORTANT: WebSocket from Browser always delivers incoming data as string, whereas in Node.js not necessarily!
        // Also Uint8Array behaves different than in Node.js, which is why we use https://www.npmjs.com/package/buffer (works in both browser and Node.js)
        const buf = buffer_1.Buffer.from(event.data);
        this.handleProtocolData(buf);
    }
    clearBuffer() {
        this.state.inputBuffer = '';
        this.state.errorBuffer = '';
        this.state.dataRawBuffer = new buffer_1.Buffer(0);
    }
    /**
     * Returns a promise that is resolved if `data` is received within `timeout` seconds,
     * otherwise rejected
     */
    readUntil(data, timeout = 10) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.readUntilData = buffer_1.Buffer.isBuffer(data) ? data : buffer_1.Buffer.from(data);
            this.state.readUntilBuffer = new buffer_1.Buffer(0);
            this.state.isReadingUntil = true;
            // Create promise
            this.state.readUntilPromise = new Promise((resolve, reject) => {
                this.state.readUntilPromiseResolve = resolve;
                this.state.readUntilPromiseReject = reject;
            });
            // Set cancel timeout
            this.state.readUntilTimeout = setTimeout(() => {
                if (this.state.isReadingUntil && this.state.readUntilPromiseReject)
                    this.state.readUntilPromiseReject(`Error: timeout in readUntil '${data}'`);
            }, timeout * 1000);
            // Return the promise
            return this.state.readUntilPromise;
        });
    }
    /**
     * Handle incoming data
     */
    handleProtocolData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            // debug2('handleProtocolData:', data)
            // Special protocol modes: GET_VER, GET_FILE, PUT_FILE
            if (this.state.replMode === ReplMode.GETVER_WAITING_RESPONSE) {
                return this.handlProtocolSpecialCommandsOutput(data);
            }
            if (this.state.isReadingUntil) {
                this.state.readUntilBuffer = buffer_1.Buffer.concat([this.state.readUntilBuffer, data]);
                if (this.state.readUntilBuffer.includes(this.state.readUntilData)) {
                    utils_1.debug2('Resolving readingUntilPromise');
                    clearTimeout(this.state.readUntilTimeout);
                    this.state.isReadingUntil = false;
                    this.state.readUntilPromiseResolve('');
                }
            }
            // If in terminal mode, just pass terminal on to user defined handler
            if (this.isConnected() && this.state.replMode === ReplMode.TERMINAL) {
                if (this.onTerminalData)
                    this.onTerminalData(data.toString());
                return;
            }
            // Extend raw data buffer (data may come in as chunks with arbitrary length)
            this.state.dataRawBuffer = buffer_1.Buffer.concat([this.state.dataRawBuffer, data]);
            // Perpare strings for easy access
            const dataStr = this.state.dataRawBuffer.toString();
            const dataTrimmed = dataStr.trim();
            utils_1.debug2('handleProtocolData', data, '=>', dataStr);
            // Handle RAW_MODE data (receiving response, receiving error, waiting for end, changing back to friendly repl)
            if (this.state.replMode === ReplMode.SCRIPT_RAW_MODE) {
                if (this.state.rawReplState === RawReplState.SCRIPT_SENT) {
                    // After script is sent, we wait for OK, then stdout_output, then \x04, then stderr_output
                    // OK[ok_output]\x04[error_output][x04]>
                    if (dataStr === 'OK') {
                        // debug('ok received, start collecting input')
                        this.clearBuffer();
                        this.state.rawReplState = RawReplState.SCRIPT_RECEIVING_RESPONSE;
                        this.state.receivingResponseSubState = RawReplReceivingResponseSubState.SCRIPT_RECEIVING_OUTPUT;
                    }
                    return;
                }
                // SCRIPT OUTPUT: OK[ok_output]\x04[error_output][x04]>
                if (this.state.rawReplState === RawReplState.SCRIPT_RECEIVING_RESPONSE) {
                    // iterate over received bytes
                    for (const entry of data) {
                        // debug(entry)
                        // There are 3 special markers: switching from output to error, from error to waiting for end, and
                        if (entry === 0x04 && this.state.receivingResponseSubState === RawReplReceivingResponseSubState.SCRIPT_RECEIVING_OUTPUT) {
                            // debug('switch to error mode')
                            this.state.receivingResponseSubState = RawReplReceivingResponseSubState.SCRIPT_RECEIVING_ERROR;
                        }
                        else if (entry === 0x04 && this.state.receivingResponseSubState === RawReplReceivingResponseSubState.SCRIPT_RECEIVING_ERROR) {
                            // debug('switch to end mode')
                            this.state.receivingResponseSubState = RawReplReceivingResponseSubState.SCRIPT_WAITING_FOR_END;
                        }
                        else if (entry === 62 && this.state.receivingResponseSubState === RawReplReceivingResponseSubState.SCRIPT_WAITING_FOR_END) {
                            // ALL DONE, now trim the buffers and resolve the promises
                            // debug('all done!!!')
                            this.state.inputBuffer = this.state.inputBuffer.trim();
                            this.state.errorBuffer = this.state.errorBuffer.trim();
                            // console.log('END', this.state.inputBuffer, this.state.errorBuffer)
                            this.state.rawReplState = RawReplState.SCRIPT_EXECUTED;
                            yield this.exitRawRepl();
                            if (this.state.errorBuffer.length > 0 && this.state.replPromiseReject) {
                                // Handle error result. Also needs to exit raw repl.
                                this.state.replPromiseReject(new errors_1.ScriptExecutionError(this.state.errorBuffer));
                            }
                            else if (this.state.replPromiseResolve) {
                                this.state.replPromiseResolve(this.state.inputBuffer);
                            }
                            this.clearBuffer();
                        }
                        else {
                            // Incoming data (stdout or stderr output). Just add to buffer
                            const char = String.fromCharCode(entry);
                            if (this.state.broadcastCommandOutputAsTerminalData && this.onTerminalData)
                                this.onTerminalData(char);
                            if (this.state.receivingResponseSubState === RawReplReceivingResponseSubState.SCRIPT_RECEIVING_OUTPUT) {
                                // debug('adding to buffer:', entry)
                                this.state.inputBuffer += char;
                            }
                            else {
                                // debug('adding to error buffer:', entry)
                                this.state.errorBuffer += char;
                            }
                        }
                    }
                }
            }
        });
    }
    sendData(data) {
        if (this.state.connectionMode === ConnectionMode.NETWORK) {
            return this.wsSendData(data);
        }
        else {
            if (data instanceof ArrayBuffer) {
                this.serialSendData(buffer_1.Buffer.from(data));
            }
            else {
                this.serialSendData(data);
            }
        }
    }
    serialSendData(data) {
        // debug('serialSendData', data)
        this.state.port.write(data);
    }
    wsSendData(data) {
        // debug('wsSendData', data)
        if (!this.state.ws || this.state.ws.readyState !== isomorphic_ws_1.default.OPEN) {
            throw new Error('wsSendData: No open websocket');
        }
        this.state.ws.send(data);
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (webserver)
                webserver.close();
            if (this.isProxyConnection()) {
                this.state.connectionState = ConnectionState.CLOSED;
                return;
            }
            else if (this.isSerialDevice()) {
                yield this.state.port.close();
                this.state.connectionState = ConnectionState.CLOSED;
            }
            else {
                yield this.closeWebsocket();
            }
        });
    }
    closeWebsocket() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state.ws && this.state.ws.readyState === isomorphic_ws_1.default.OPEN) {
                // console.log('closing')
                this.state.ws.close();
                this.state.connectionState = ConnectionState.CLOSED;
                return this.createReplPromise();
            }
            else {
                utils_1.debug('Websocket already closed');
                return false;
            }
        });
    }
    /**
     * Execute a Python script on the device, wait and return the output.
     *
     * @param script the python code
     * @param options
     *
     * @throws {ScriptExecutionError} on Python code execution error. Includes the Python traceback.
     */
    runScript(script, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            // Prepare script for execution (dedent by default)
            if (!options.disableDedent)
                script = utils_1.dedent(script);
            if (options.runGcCollectBeforeCommand)
                script = "import gc; gc.collect();\n" + script;
            utils_1.debug(`runScript\n${script}`);
            if (this.isProxyConnection()) {
                let url = `http://localhost:${settings_1.WEBSERVER_PORT}/api/run-script/`;
                if (options.stayInRawRepl)
                    url += `?stayInRawRepl=1`;
                utils_1.debug('run over api', url);
                const resp = yield fetch(url, { method: 'POST', body: script });
                const content = yield resp.text();
                if (resp.status === 512) {
                    // ScriptExecutionError
                    throw new errors_1.ScriptExecutionError(content);
                }
                else if (resp.status !== 200) {
                    throw new errors_1.ScriptExecutionError(`Could not run script via api: status=${resp.status} ${content}`);
                }
                return content;
            }
            yield this.enterRawRepl();
            utils_1.debug('runScript: raw mode entered');
            // Send data to raw repl. Note: cannot send too much data at once over the
            // network, else the webrepl can't parse it quick enough and returns an error.
            // Therefore we chunk the data and add a send delay.
            // 120b and 180ms delay seems to work well for all ESP32 devices.
            const chunkSize = this.isSerialDevice() ? 3000 : 120; // how many bytes to send per chunk.
            const chunkDelayMillis = this.isSerialDevice() ? 0 : 200; // fixed delay. a progressive delay doesn't seem to help
            utils_1.debug(`runScript: ${script.length} bytes -> ${Math.ceil(script.length / chunkSize)} chunks`);
            while (script.length) {
                const chunk = script.substring(0, chunkSize);
                script = script.substr(chunkSize);
                this.sendData(chunk);
                if (chunkDelayMillis && script.length)
                    yield delayMillis(chunkDelayMillis);
            }
            // debug('runScript: script sent')
            const millisStart = Date.now();
            // Update state and create a new promise that will be fulfilled when script has run
            this.state.broadcastCommandOutputAsTerminalData = !!options.broadcastOutputAsTerminalData;
            this.state.rawReplState = RawReplState.SCRIPT_SENT;
            const promise = this.createReplPromise();
            // Send ctrl+D to execute the uploaded script in the raw repl
            this.sendData('\x04');
            utils_1.debug('runScript: script sent, waiting for response');
            if (options.resolveBeforeResult)
                return '';
            // wait for script execution
            const scriptOutput = yield promise;
            utils_1.debug('output', scriptOutput);
            const millisRuntime = Math.round(Date.now() - millisStart);
            utils_1.debug(`runScript: script done (${millisRuntime / 1000}sec)`);
            this.state.lastRunScriptTimeNeeded = millisRuntime;
            // await this.exitRawRepl()
            return scriptOutput;
        });
    }
    enterRawRepl() {
        return __awaiter(this, void 0, void 0, function* () {
            // see also https://github.com/scientifichackers/ampy/blob/master/ampy/pyboard.py#L175
            // debug('enterRawRepl')
            if (this.state.replMode === ReplMode.SCRIPT_RAW_MODE) {
                return utils_1.debug('enterRawRepl: already in raw repl mode');
            }
            this.state.replMode = ReplMode.SCRIPT_RAW_MODE;
            // Send ctrl-C twice to interrupt any running program
            this.sendData('\r\x03\x03');
            // await delayMillis(100) // wait 0.1sec
            try {
                yield this.readUntil('>>>', 5);
            }
            catch (_a) {
                // Might be stuck in raw repl. Try to exit into friendly repl with Ctrl+B
                this.sendData('\r\x03\x02');
                yield this.readUntil('>>>', 5);
            }
            this.sendData('\x01'); // ctrl+A
            yield this.readUntil('raw REPL; CTRL-B to exit\r\n>');
            this.clearBuffer();
            this.state.rawReplState = RawReplState.WAITING_FOR_SCRIPT;
        });
    }
    exitRawRepl() {
        return __awaiter(this, void 0, void 0, function* () {
            // debug('exitRawRepl')
            if (this.state.replMode !== ReplMode.SCRIPT_RAW_MODE)
                return;
            this.sendData('\r\x02');
            yield this.readUntil('>>>');
            this.state.replMode = ReplMode.TERMINAL;
        });
    }
    /**
     * GET_VER webrepl command. Returns the micropython version.
     * Only works with network connections, not with serial.
     */
    getVer() {
        return __awaiter(this, void 0, void 0, function* () {
            // debug(`getVer`)
            if (this.isSerialDevice()) {
                throw new Error("getVer is not possible with a serial connection (only with webrepl)");
            }
            const promise = this.createReplPromise();
            this.state.replMode = ReplMode.GETVER_WAITING_RESPONSE;
            // WEBREPL_REQ_S = "<2sBBQLH64s"
            const rec = new Uint8Array(2 + 1 + 1 + 8 + 4 + 2 + 64);
            rec[0] = 'W'.charCodeAt(0);
            rec[1] = 'A'.charCodeAt(0);
            rec[2] = 3; // GET_VER
            // initiate put
            this.sendData(rec);
            const ret = yield promise;
            return ret;
        });
    }
    // public async uploadFile(filename: string, destFilename: string) {
    //   debug(`uploadFile: ${filename} -> ${destFilename}`)
    //   // const promise = this.createReplPromise()
    //   // this.state.replMode = WebReplMode.PUTFILE_WAITING_FIRST_RESPONSE
    //   // this.state.putFileName = filename
    //   // this.state.putFileDest = destFilename
    //   // this.state.putFileData = new Uint8Array(fs.readFileSync(filename))
    //   // this.state.putFileSize = this.state.putFileData.length
    //   // debug(`uploadFile: ${this.state.putFileSize} bytes`)
    //   // // WEBREPL_FILE = "<2sBBQLH64s"
    //   // const rec = new Uint8Array(2 + 1 + 1 + 8 + 4 + 2 + 64);
    //   // rec[0] = 'W'.charCodeAt(0);
    //   // rec[1] = 'A'.charCodeAt(0);
    //   // rec[2] = 1; // put
    //   // rec[3] = 0;
    //   // rec[4] = 0; rec[5] = 0; rec[6] = 0; rec[7] = 0; rec[8] = 0; rec[9] = 0; rec[10] = 0; rec[11] = 0;
    //   // // tslint:disable-next-line: no-bitwise
    //   // rec[12] = this.state.putFileSize & 0xff; rec[13] = (this.state.putFileSize >> 8) & 0xff; rec[14] = (this.state.putFileSize >> 16) & 0xff; rec[15] = (this.state.putFileSize >> 24) & 0xff;
    //   // // tslint:disable-next-line: no-bitwise
    //   // rec[16] = this.state.putFileDest.length & 0xff; rec[17] = (this.state.putFileDest.length >> 8) & 0xff;
    //   // for (let i = 0; i < 64; ++i) {
    //   //   rec[18 + i] = i < this.state.putFileDest.length ? this.state.putFileDest.charCodeAt(i) : 0
    //   // }
    //   // // initiate put
    //   // this.sendData(rec)
    //   // return promise
    // }
    listFiles(directory = '/', options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const recursive = !!options.recursive;
            const includeSha256 = !!options.includeSha256;
            utils_1.debug(`listFiles: ${directory}, ${recursive}`);
            const output = yield this.runScript(PythonScripts.ls({ directory, recursive, includeSha256 }));
            const lines = output.split('\n');
            const ret = [];
            for (const line of lines) {
                const parts = line.trim().split(' | ');
                if (parts[0] === '')
                    continue;
                ret.push({
                    filename: parts[0],
                    size: parseInt(parts[2], 10),
                    isDir: parts[1] === 'd',
                    mTime: parseInt(parts[3], 10),
                    sha256: parts[4]
                });
            }
            return ret;
        });
    }
    /**
     * Get the contents of a file.
     *
     * ```typescript
     * const data = await micropython.getFile('boot.py')
     * ```
     *
     * @returns {Buffer} contents of the file in a Buffer
     * @param filename filename of file to download
     * @throws {ScriptExecutionError} if not found: "`OSError: [Errno 2] ENOENT`"
     */
    getFile(filename) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.debug(`getFile: ${filename}`);
            const output = yield this.runScript(PythonScripts.getFile(filename));
            return buffer_1.Buffer.from(output, 'hex');
        });
    }
    statPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.debug(`statPath: ${path}`);
            const statOutput = yield this.runScript(PythonScripts.stat(path));
            if (statOutput.trim() === 'x')
                return { exists: false, isDir: false, size: 0 };
            const [isDir, size] = statOutput.split(' | ');
            return { exists: true, isDir: isDir === 'd', size: parseInt(size, 10) };
        });
    }
    /**
     *
     * @param name
     * @throws {ScriptExecutionError}
     */
    mkdir(name) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.debug(`mkdir: ${name}`);
            const script = `import os; os.mkdir('${name}')`;
            yield this.runScript(script);
            return true;
        });
    }
    /**
     * Uploading data to the device, saving as a file.
     *
     * We break the buffer into multiple chunks, and execute a raw repl command for each of them
     * in order to not fill up the device RAM.
     *
     * See also:
     * - https://github.com/dhylands/rshell/blob/master/rshell/main.py#L1079
     * - https://github.com/scientifichackers/ampy/blob/master/ampy/files.py#L209
     *
     * @param targetFilename
     * @param data
     */
    putFile(targetFilename, data, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.debug(`putFile: ${targetFilename} (${data.length})`);
            if (options.checkIfSimilarBeforeUpload) {
                const isAlreadyTheSame = yield this.isFileTheSame(targetFilename, data);
                if (isAlreadyTheSame)
                    return true;
            }
            this.createReplPromise();
            const dataHex = data.toString('hex');
            // const chunkSize = this.isSerialDevice() ? 256 : 64
            const chunkSize = this.isProxyConnection() ? 5000 : this.isSerialDevice() ? 3000 : 64;
            const script1 = `import ubinascii; f = open('${targetFilename}', 'wb')`;
            yield this.runScript(script1, { stayInRawRepl: true, runGcCollectBeforeCommand: true }); // keeps raw repl open for next instruction
            for (let index = 0; index < dataHex.length; index += chunkSize) {
                const chunk = dataHex.substr(index, chunkSize);
                utils_1.debug('chunk', chunk);
                const scriptForChunk = `f.write(ubinascii.unhexlify("${chunk}"))`;
                yield this.runScript(scriptForChunk, { stayInRawRepl: true }); // keeps raw repl open for next instruction
            }
            yield this.runScript('f.close()'); // finally closes raw repl, switching back to friendly
            return true;
        });
    }
    /**
     * Remove a file or directory. Optional recursively
     *
     * @param path
     * @param recursive default: false
     *
     * @throws {ScriptExecutionError} if not found: "OSError: [Errno 2] ENOENT"
     * @throws {ScriptExecutionError} if directory not empty: "OSError: 39"
     */
    remove(path, recursive = false) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.debug('remove', path, recursive);
            const script = recursive ? PythonScripts.deleteEverythingRecurive(path) : `import os; os.remove("${path}")`;
            yield this.runScript(script);
        });
    }
    /**
     * Rename a file or directory (uos.rename)
     *
     * @throws {ScriptExecutionError} if not found: "OSError: [Errno 2] ENOENT"
     * @throws {ScriptExecutionError} if directory not empty: "OSError: 39"
     */
    rename(oldPath, newPath) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.debug('rename', oldPath, newPath);
            const script = `import os; os.rename("${oldPath}", "${newPath}")`;
            yield this.runScript(script);
        });
    }
    /**
     * Reset a device.
     */
    reset(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const script = options.softReset ? 'import sys; sys.exit()' : 'import machine; machine.reset()';
            utils_1.debug('reset', script, options);
            // Need to exit after sending, because it will not exit the RAW repl mode like any other script
            // since the device is actually restarting.
            yield this.runScript(script, {
                broadcastOutputAsTerminalData: options.broadcastOutputAsTerminalData,
                resolveBeforeResult: true
            });
            // Serial connection stays open after reset, webrepl closes
            if (this.isSerialDevice()) {
                yield delayMillis(1000);
                yield this.exitRawRepl();
            }
        });
    }
    /**
     * Get SHA256 hash of a file contents.
     *
     * ```typescript
     * const data = await micropython.getFileHash('boot.py')
     * ```
     *
     * @param filename filename of target file
     * @returns sha256 hash, hexlified
     * @throws {ScriptExecutionError} if not found: "`OSError: [Errno 2] ENOENT`"
     */
    getFileHash(filename) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.debug('getFileHash', filename);
            const script = PythonScripts.getFileHash(filename);
            const sha256HexDigest = yield this.runScript(script);
            return sha256HexDigest;
        });
    }
    /**
     * Check whether a file is the same as provided, within a single `runScript` execution.
     * Does not work in browser.
     *
     * - If filesize is different, then file is different
     * - If filesize equal then compare sha256 hash
     *
     * This is a helper for bulk uploading directories, but only if they have changed.
     *
     * @throws {ScriptExecutionError} if not found: "OSError: [Errno 2] ENOENT"
     */
    isFileTheSame(filename, data) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.debug('isFileTheSame', filename, data.length);
            const crypto = require('crypto');
            const localHash = crypto.createHash('sha256').update(data).digest('hex');
            const script = PythonScripts.isFileTheSame(filename, data.length, localHash);
            const output = yield this.runScript(script);
            return output === '1';
        });
    }
    /**
     * Get information about the board.
     *
     * ```typescript
     * const boardInfo = await micropython.getBoardInfo()
     * console.log(boardInfo)
     *
     * {
     *   sysname: 'esp32',
     *   nodename: 'esp32',
     *   release: '1.13.0',
     *   version: 'v1.13 on 2020-09-02',
     *   machine: 'ESP32 module with ESP32',
     *   uniqueId: 'c44f3312f529',
     *   memFree: 108736,
     *   fsBlockSize: 4096,
     *   fsBlocksTotal: 512,
     *   fsBlocksFree: 438
     * }
     * ```
     */
    getBoardInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.debug('getBoardInfo');
            const script = `
      import uos, machine, ubinascii, gc
      try:
        unique_id = ubinascii.hexlify(machine.unique_id())
      except:
        unique_id = None
      gc.collect()
      print('mem_free:', gc.mem_free())
      print('uname:', uos.uname())
      print('unique_id:', unique_id)
      print('fsinfo:', uos.statvfs('/'))
    `;
            const output = yield this.runScript(script);
            const ret = {};
            for (const line of output.split('\n')) {
                const infoType = line.split(': ')[0];
                const infoData = line.replace(/^.*: /, '').trim();
                if (infoType === 'uname') {
                    const parts = infoData.substr(1, infoData.length - 2).split(', ');
                    parts.map(part => {
                        const _parts = part.split('=');
                        ret[_parts[0]] = _parts[1].substr(1, _parts[1].length - 2);
                    });
                }
                else if (infoType === 'unique_id') {
                    // console.log(infoData)
                    ret.uniqueId = infoData === 'None' ? null : infoData.substr(2, infoData.length - 3);
                }
                else if (infoType === 'mem_free') {
                    ret.memFree = parseInt(infoData, 10);
                }
                else if (infoType === 'fsinfo') {
                    const parts = infoData.substr(1, infoData.length - 2).split(', ');
                    ret.fsBlockSize = parseInt(parts[0], 10);
                    ret.fsBlocksTotal = parseInt(parts[2], 10);
                    ret.fsBlocksFree = parseInt(parts[3], 10);
                }
            }
            return ret;
        });
    }
    gcCollect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.runScript('import gc; gc.collect();');
        });
    }
}
exports.MicroPythonDevice = MicroPythonDevice;
//# sourceMappingURL=main.js.map