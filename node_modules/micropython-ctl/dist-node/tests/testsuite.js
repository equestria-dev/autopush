"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
/**
 * This is a test script, to check all commands on a physical device
 */
const main_1 = require("../src/main");
// import { MicroPythonDevice } from 'micropython-ctl';
const assert_1 = __importDefault(require("assert"));
const crypto_1 = __importDefault(require("crypto"));
const buffer_1 = require("buffer/");
const serialport_1 = __importDefault(require("serialport"));
const utils_1 = require("../src/utils");
const commander_1 = require("commander");
const listSerialDevices = () => __awaiter(void 0, void 0, void 0, function* () {
    const devices = yield serialport_1.default.list();
    return devices.filter(device => device.manufacturer || device.serialNumber || device.vendorId);
});
// Get first serial device
const getSerialDevice = () => __awaiter(void 0, void 0, void 0, function* () {
    if (process.env.DEVICE_SERIAL)
        return process.env.DEVICE_SERIAL;
    const goodDevices = yield listSerialDevices();
    if (!goodDevices.length)
        throw new Error('No serial devices found');
    return goodDevices[0].path;
});
const runTests = (micropython) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        assert_1.default(micropython.isConnected());
        assert_1.default(micropython.isTerminalMode());
        console.log('- testing repl mode');
        let terminalDataReceived = '';
        micropython.onTerminalData = (data) => terminalDataReceived += data;
        micropython.sendData('\x03\x02');
        yield utils_1.delayMillis(1000);
        micropython.sendData('foo');
        yield utils_1.delayMillis(1000);
        // console.log('terminalDataReceived', terminalDataReceived)
        assert_1.default(terminalDataReceived.trim().endsWith('>>> foo'));
        // tslint:disable-next-line: no-empty
        micropython.onTerminalData = (_data) => { };
        console.log('- getBoardInfo()');
        const boardInfo = yield micropython.getBoardInfo();
        if (micropython.isSerialDevice() && boardInfo.sysname === 'esp32') {
            // Serial device keeps connection alive on reset. Only on ESP32?
            console.log('- testing hard reset');
            let terminalData = '';
            micropython.onTerminalData = (data) => terminalData += data;
            yield micropython.reset({ broadcastOutputAsTerminalData: true });
            // await delayMillis(2000)
            // console.log('terminalData', terminalData)
            const hasV113Info = terminalData.includes('cpu_start:') && terminalData.includes('heap_init:');
            const hasV114Info = terminalData.includes('load:0x');
            assert_1.default(hasV113Info || hasV114Info);
            // tslint:disable-next-line: no-empty
            micropython.onTerminalData = (_data) => { };
        }
        console.log('- creating test directory');
        const testPath = '/MicroPythonCtlTestRun';
        const statTestPath = yield micropython.statPath(testPath);
        if (statTestPath.exists) {
            yield micropython.remove(testPath, true);
        }
        // Create test
        yield micropython.mkdir(testPath);
        const filesInTestDir1 = yield micropython.listFiles(testPath);
        const b1 = buffer_1.Buffer.from('this is a testfile');
        const b1fn = testPath + '/file1.txt';
        const b2 = buffer_1.Buffer.from(crypto_1.default.randomBytes(2742));
        const b2Hash = crypto_1.default.createHash('sha256').update(b2).digest('hex');
        const b2fn = testPath + '/file2.txt';
        console.log('- put file 1 (small)');
        yield micropython.putFile(b1fn, b1);
        console.log('- put file 2 (large)');
        yield micropython.putFile(b2fn, b2);
        console.log('- listing files...');
        const filesInTestDir2 = yield micropython.listFiles(testPath);
        // console.log(filesInTestDir2)
        assert_1.default(filesInTestDir2.length = 2);
        assert_1.default(filesInTestDir2[0].size === 18);
        assert_1.default(filesInTestDir2[1].size === b2.length);
        console.log('- downloading large file, check if equal to original...');
        const b2ContentsAfter = yield micropython.getFile(b2fn);
        const b2HashAfter = crypto_1.default.createHash('sha256').update(b2ContentsAfter).digest('hex');
        assert_1.default(b2Hash === b2HashAfter);
        console.log('- creating subdirectories');
        yield micropython.mkdir(testPath + '/subpath1');
        yield micropython.mkdir(testPath + '/subpath1/subsub1');
        yield micropython.mkdir(testPath + '/subpath2');
        console.log('- uploading file into /subpath1');
        yield micropython.putFile(testPath + '/subpath1/file1.txt', b1);
        console.log('- check listFiles recursive');
        const filesInTestDir3 = yield micropython.listFiles(testPath, { recursive: true });
        const onlyDirs = filesInTestDir3.filter(file => file.isDir);
        const onlyFiles = filesInTestDir3.filter(file => !file.isDir);
        assert_1.default(onlyDirs.length === 4);
        assert_1.default(onlyFiles.length === 3);
        console.log('- removing a file and checking listFiles');
        yield micropython.remove(b1fn);
        const filesInTestDir4 = yield micropython.listFiles(testPath, { recursive: true });
        const onlyFiles4 = filesInTestDir4.filter(file => !file.isDir);
        assert_1.default(onlyFiles4.length === 2);
        console.log('- removing subpath1 recursively');
        yield micropython.remove(testPath + '/subpath1', true);
        const filesInTestDir5 = yield micropython.listFiles(testPath, { recursive: true });
        const onlyDirs5 = filesInTestDir5.filter(file => file.isDir);
        const onlyFiles5 = filesInTestDir5.filter(file => !file.isDir);
        assert_1.default(onlyDirs5.length === 2);
        assert_1.default(onlyFiles5.length === 1);
        console.log('- statPath');
        const stat1 = yield micropython.statPath(testPath);
        assert_1.default(stat1.exists && stat1.isDir);
        const stat2 = yield micropython.statPath(b2fn);
        assert_1.default(stat2.exists && !stat2.isDir && stat2.size === b2.length);
        console.log('- rename');
        yield micropython.rename(b2fn, b2fn + 'xxx');
        const statOld = yield micropython.statPath(b2fn);
        const statNew = yield micropython.statPath(b2fn + 'xxx');
        assert_1.default(!statOld.exists);
        assert_1.default(statNew.exists && !statNew.isDir && statNew.size === b2.length);
        console.log('- cleanup...');
        yield micropython.remove(testPath, true);
        console.log('- disconnect');
        let isClosed = false;
        micropython.onclose = () => isClosed = true;
        yield micropython.disconnect();
        yield utils_1.delayMillis(1000);
        assert_1.default(isClosed);
        assert_1.default(!micropython.isConnected());
        // ALL DONE
        console.log('\nâœ… all checks completed');
    }
    catch (e) {
        console.error(e);
        process.exit(1);
    }
    finally {
        yield micropython.disconnect();
    }
});
const runTestsOnSerial = (ttyPath) => __awaiter(void 0, void 0, void 0, function* () {
    // Run tests over serial connection
    const serialDevice = ttyPath || (yield getSerialDevice());
    console.log('Running tests on device over serial connection', serialDevice);
    const micropython = new main_1.MicroPythonDevice();
    yield micropython.connectSerial(serialDevice);
    assert_1.default(micropython.isSerialDevice());
    yield runTests(micropython);
});
const runTestsOnNetwork = (host, password) => __awaiter(void 0, void 0, void 0, function* () {
    console.log('Runnig tests on device over network connection', host);
    const micropython = new main_1.MicroPythonDevice();
    yield micropython.connectNetwork(host, password);
    yield runTests(micropython);
});
const program = new commander_1.Command();
program.option('-t, --tty [device]', `Connect over serial interface (eg. /dev/tty.SLAB_USBtoUART)`);
program.option('-h, --host <host>', `Connect over network to hostname or IP of device`);
program.option('-p, --password <password>', `Password for network device`);
const run = () => __awaiter(void 0, void 0, void 0, function* () {
    program.parse(process.argv);
    const opts = program.opts();
    if (opts.host) {
        if (!opts.password) {
            return console.error('Password missing');
        }
        yield runTestsOnNetwork(opts.host, opts.password);
    }
    else {
        yield runTestsOnSerial(opts.tty);
    }
});
exports.run = run;
if (require.main === module) {
    exports.run();
}
//# sourceMappingURL=testsuite.js.map