#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Command line interface for talking to MicroPython devices over serial or network (webrepl)
 *
 * https://github.com/metachris/micropython-ctl/tree/master/cli
 *
 * Installed as `mctl`. Install with:
 *
 *     $ npm install -g micropython-ctl
 *
 * Usage:
 *
 *     $ mctl --help
 *     $ mctl devices
 *     $ mctl ls -r
 *     $ mctl repl
 *     $ mctl mount
 *
 * Supports env vars:
 * - serial connection: MCTL_TTY, AMPY_PORT
 * - network connection: MCTL_HOST, WEBREPL_HOST
 *
 * Issues & TODO: https://github.com/metachris/micropython-ctl/issues/3
 */
const path = __importStar(require("path"));
const fs_1 = __importDefault(require("fs"));
const crypto_1 = __importDefault(require("crypto"));
const child_process_1 = require("child_process");
const readline_1 = __importDefault(require("readline"));
const buffer_1 = require("buffer/");
const serialport_1 = __importDefault(require("serialport"));
const commander_1 = require("commander");
const main_1 = require("../src/main");
const utils_1 = require("../src/utils");
const utils_2 = require("./utils");
const utils_node_1 = require("../src/utils-node");
const mount_device_1 = require("./mount-device");
const fuse_dependencies_1 = require("./fuse-dependencies");
const testsuite_1 = require("../tests/testsuite");
// tslint:disable-next-line: no-var-requires
const pjson = require('../package.json');
// https://github.com/tj/commander.js
const program = new commander_1.Command();
// https://metachris.github.io/micropython-ctl/classes/micropythondevice.html
const micropython = new main_1.MicroPythonDevice();
process.on('unhandledRejection', error => {
    console.log(error);
    console.log('Please open an issue at https://github.com/metachris/micropython-ctl/issues');
    process.exit(2);
});
const CLR_RESET = "\x1b[0m";
const CLR_FG_BLUE = "\x1b[34m";
const CLR_FG_RED = "\x1b[31m";
const CLR_FG_YELLOW = "\x1b[33m";
const logError = (...msg) => {
    process.stderr.write(CLR_FG_RED);
    console.error(...msg, CLR_RESET);
};
const logVerbose = (...msg) => {
    if (!program.opts().silent) {
        console.log(...msg);
    }
};
const listSerialDevices = () => __awaiter(void 0, void 0, void 0, function* () {
    const devices = yield serialport_1.default.list();
    // Apply some filters
    return devices.filter(device => device.manufacturer || device.serialNumber || device.vendorId);
});
/**
 * Auto-connect priorities:
 * 1. --host or --tty option
 * 2. MCTL_TTY or AMPY_PORT -> serial connection
 * 3. MCTL_HOST or WEBREPL_HOST -> network connection
 */
const ensureConnectedDevice = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const opts = program.opts();
    const tty = opts.tty;
    const host = opts.host;
    const password = opts.password;
    const envWebreplHost = process.env.WEBREPL_HOST;
    const envMctlHost = process.env.MCTL_HOST;
    const envMctlTty = process.env.MCTL_TTY;
    const envAmpyPort = process.env.AMPY_PORT;
    // Disable info output when --json in arguments
    const doPrint = program.args.indexOf("--json") === -1;
    // Connect via network if host is defined, or if no tty specified then check env vars
    const shouldConnectToSerial = () => {
        if (tty)
            return true;
        if (host)
            return false;
        if (envMctlTty)
            return true;
        if (envMctlHost)
            return false;
        if (envWebreplHost)
            return false;
        return true;
    };
    try {
        // Do nothign if already connected
        if (micropython.isConnected())
            return;
        if (shouldConnectToSerial()) {
            const getSerialDevice = () => __awaiter(void 0, void 0, void 0, function* () {
                if (tty)
                    return tty; // -t / --tty option
                if (envMctlTty)
                    return envMctlTty; // MCTL_TTY env var
                if (envAmpyPort)
                    return envAmpyPort; // AMPY_PORT env var
                const devices = yield listSerialDevices(); // Auto-detect devices and use first one
                if (devices.length === 0)
                    throw new Error('No serial device found');
                return devices[0].path;
            });
            const device = yield getSerialDevice();
            if (doPrint)
                logVerbose(`Connecting over serial to: ${device}`);
            yield micropython.connectSerial(device);
        }
        else {
            const _host = host || envMctlHost || envWebreplHost;
            const _pass = password || process.env.MCTL_PASSWORD || process.env.WEBREPL_PASSWORD;
            if (doPrint)
                logVerbose(`Connecting over network to: ${_host}`);
            if (!_pass)
                throw new Error('No webrepl password supplied');
            yield micropython.connectNetwork(_host, _pass);
        }
        // Start proxy webserver
        if (options === null || options === void 0 ? void 0 : options.startWebserver)
            micropython.startInternalWebserver();
        if (micropython.isProxyConnection()) {
            logVerbose(`Reusing an existing instance via http://localhost:${main_1.WEBSERVER_PORT}/api/`);
        }
    }
    catch (e) {
        logError('Could not connect:', e.toString());
        process.exit(1);
    }
});
// mctl devices
const cmdListDevices = () => __awaiter(void 0, void 0, void 0, function* () {
    (yield listSerialDevices()).map(device => console.log(device.path, '\t', device.manufacturer));
});
// mctl ls [-r]
const listFilesOnDevice = (directory = '/', cmdObj) => __awaiter(void 0, void 0, void 0, function* () {
    // console.log('listFilesOnDevice', directory, cmdObj)
    yield ensureConnectedDevice();
    try {
        const files = yield micropython.listFiles(directory, { recursive: cmdObj.recursive, includeSha256: !!cmdObj.includeHash });
        if (cmdObj.json || cmdObj.includeHash) {
            // Output in JSON
            const s = JSON.stringify(files, null, 4);
            console.log(s);
        }
        else {
            // Output for humans
            files.map(file => console.log(`${utils_2.humanFileSize(file.size).padStart(5)} ${file.isDir ? CLR_FG_BLUE : ''}${file.filename}${CLR_RESET}`));
        }
    }
    catch (e) {
        if (e instanceof main_1.ScriptExecutionError && e.message.includes('OSError: [Errno 2] ENOENT')) {
            logError(`ls: cannot access '${directory}': No such file or directory`);
            return;
        }
        console.log('Error:', e);
        process.exit(1);
    }
    finally {
        yield micropython.disconnect();
    }
});
/**
 * Upload a file
 *
 * filenames when copying from local -> device:
 * - boot.py     -> boot.py
 * - test/foo.py -> foo.py
 * - test/       -> test/foo.py
 *
 * @param filename filename, glob or directory name
 * @param dest filename or path
 */
const put = (filename, dest, cmdObj) => __awaiter(void 0, void 0, void 0, function* () {
    logVerbose('put', filename, '->', dest);
    const { changedOnly } = cmdObj;
    // helper to perform individual upload
    const uploadSingleFile = (_filename, _dest = dest) => __awaiter(void 0, void 0, void 0, function* () {
        let target = path.basename(_filename);
        if (_dest) {
            target = _dest.endsWith('/') ? _dest + target : _dest;
        }
        console.log('put:', _filename, '->', target);
        const data = buffer_1.Buffer.from(fs_1.default.readFileSync(_filename));
        yield micropython.putFile(target, data, { checkIfSimilarBeforeUpload: changedOnly });
    });
    const uploadDirectory = (_dirname) => __awaiter(void 0, void 0, void 0, function* () {
        if (_dirname.endsWith('/'))
            _dirname = _dirname.substr(0, _dirname.length - 1);
        // console.log('uploadDir', _dirname)
        // create dir on device, if not exists
        const deviceStat = yield micropython.statPath(_dirname);
        if (!deviceStat.exists) {
            yield micropython.mkdir(_dirname);
        }
        // Iterate over all files and directories, and upload
        for (const _filename of fs_1.default.readdirSync(_dirname)) {
            const fn = path.join(_dirname, _filename);
            const stat = fs_1.default.statSync(fn);
            if (stat.isFile()) {
                yield uploadSingleFile(fn, _dirname === '.' ? '/' : _dirname + '/');
            }
            else if (stat.isDirectory()) {
                yield uploadDirectory(fn);
            }
        }
    });
    // Connect and upload
    try {
        yield ensureConnectedDevice();
        // Is argument glob?
        if (filename.indexOf('*') > -1) {
            const filesDir = path.dirname(filename);
            const filesRegex = utils_node_1.globToRegExp(path.basename(filename));
            const files = fs_1.default.readdirSync(filesDir).filter(dir => filesRegex.test(dir));
            for (const _filename of files) {
                yield uploadSingleFile(_filename);
            }
            return;
        }
        // Else file or directory
        const stat = fs_1.default.statSync(filename);
        if (stat.isFile()) {
            yield uploadSingleFile(filename);
        }
        else if (stat.isDirectory()) {
            yield uploadDirectory(filename);
        }
    }
    finally {
        yield micropython.disconnect();
    }
});
const mkdir = (name) => __awaiter(void 0, void 0, void 0, function* () {
    logVerbose('mkdir', name);
    yield ensureConnectedDevice();
    try {
        yield micropython.mkdir(name);
    }
    catch (e) {
        if (e instanceof main_1.ScriptExecutionError && e.message.includes('OSError: [Errno 17] EEXIST')) {
            logError(`mkdir: cannot create directory '${name}': File exists`);
            return;
        }
        console.log('Error:', e);
        process.exit(1);
    }
    finally {
        yield micropython.disconnect();
    }
});
const boardInfo = (cmdObj) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield ensureConnectedDevice();
        const info = yield micropython.getBoardInfo();
        if (cmdObj.json) {
            const s = JSON.stringify(info, null, 4);
            console.log(s);
        }
        else {
            console.log(info);
        }
    }
    finally {
        yield micropython.disconnect();
    }
});
const catFile = (filename) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield ensureConnectedDevice();
        if (!filename.startsWith('/'))
            filename = '/' + filename;
        const contents = yield micropython.getFile(filename);
        console.log(contents.toString());
    }
    catch (e) {
        if (e instanceof main_1.ScriptExecutionError && e.message.includes('OSError: [Errno 2] ENOENT')) {
            logError(`cat: cannot access '${filename}': No such file or directory`);
            return;
        }
        else if (e instanceof main_1.ScriptExecutionError && e.message.includes('OSError: [Errno 21] EISDIR')) {
            logError(`cat: cannot read '${filename}' beacuse it is a directory`);
            return;
        }
        logError('Error:', e);
        process.exit(1);
    }
    finally {
        yield micropython.disconnect();
    }
});
const get = (filenameOrDir, targetFilenameOrDir) => __awaiter(void 0, void 0, void 0, function* () {
    // console.log('get', filenameOrDir, targetFilenameOrDir)
    try {
        yield ensureConnectedDevice();
        // . is an alias for: `get -r .` is `get -r /`
        if (filenameOrDir === '.')
            filenameOrDir = '/';
        // handle glob pattern (eg. '*.py')
        if (filenameOrDir.startsWith('*.') || filenameOrDir.endsWith('*')) {
            // TODO
            console.log('patterns not yet implemented');
            return;
        }
        // filename must have trailing slash
        if (!filenameOrDir.startsWith('/'))
            filenameOrDir = '/' + filenameOrDir;
        // check if path exists
        const statResult = yield micropython.statPath(filenameOrDir);
        if (!statResult.exists) {
            logError(`get: cannot access '${filenameOrDir}': No such file or directory`);
            return;
        }
        if (statResult.isDir) {
            if (!targetFilenameOrDir) {
                targetFilenameOrDir = '.';
            }
            // remove possible trailing slash
            if (targetFilenameOrDir.endsWith('/'))
                targetFilenameOrDir = targetFilenameOrDir.substr(0, targetFilenameOrDir.length - 1);
            // make sure target directory exists
            if (!fs_1.default.existsSync(targetFilenameOrDir)) {
                // console.log('- mkdir', targetFilenameOrDir)
                fs_1.default.mkdirSync(targetFilenameOrDir);
            }
            const downloadDirectory = (downloadDir) => __awaiter(void 0, void 0, void 0, function* () {
                // console.log('downloadDir',  downloadDir)
                const fullTargetDir = path.join(targetFilenameOrDir, downloadDir);
                if (!fs_1.default.existsSync(fullTargetDir)) {
                    // console.log('- mkdir', targetFilenameOrDir + downloadDir)
                    fs_1.default.mkdirSync(fullTargetDir);
                }
                // copy everything recursively!
                const filesAndDirectories = yield micropython.listFiles(downloadDir, { recursive: true });
                // console.log(filesAndDirectories)
                for (const item of filesAndDirectories) {
                    const targetFileName = path.join(targetFilenameOrDir, item.filename);
                    if (item.filename === downloadDir)
                        continue; // don't re-download self
                    if (item.isDir) {
                        if (!fs_1.default.existsSync(targetFileName)) {
                            // console.log('- mkdir', targetFileName)
                            fs_1.default.mkdirSync(targetFileName);
                        }
                    }
                    else {
                        console.log('get:', item.filename, '->', targetFileName);
                        const contents = yield micropython.getFile(item.filename);
                        fs_1.default.writeFileSync(targetFileName, contents);
                    }
                }
            });
            yield downloadDirectory(filenameOrDir);
        }
        else {
            // It is a file.
            // TODO: handle glob, like in `putFile`
            // Define the target filename
            let targetFilename = path.basename(filenameOrDir); // removed the directory
            // If explicit target is supplied, it can be a directory or a filename
            if (targetFilenameOrDir) {
                targetFilename = targetFilenameOrDir.endsWith('/') ? targetFilenameOrDir + targetFilename : targetFilenameOrDir;
            }
            console.log(`get: ${filenameOrDir} -> ${targetFilename}`);
            const contents = yield micropython.getFile(filenameOrDir);
            fs_1.default.writeFileSync(targetFilename, contents);
        }
    }
    catch (e) {
        console.log('Error:', e);
        process.exit(1);
    }
    finally {
        yield micropython.disconnect();
    }
});
const rm = (targetPath, cmdObj) => __awaiter(void 0, void 0, void 0, function* () {
    if (!targetPath.startsWith('/'))
        targetPath = '/' + targetPath;
    // logVerbose('rm', targetPath)
    try {
        yield ensureConnectedDevice();
        yield micropython.remove(targetPath, cmdObj.recursive);
    }
    catch (e) {
        if (e instanceof main_1.ScriptExecutionError && e.message.includes('OSError: 39')) {
            logError(`rm: cannot remove '${targetPath}': Is a directory. (use -r to delete recursively)`);
            return;
        }
        else if (e instanceof main_1.ScriptExecutionError && e.message.includes('OSError: [Errno 2] ENOENT')) {
            logError(`rm: cannot remove '${targetPath}': No such file or directory`);
            return;
        }
        console.error('Error:', e);
        process.exit(1);
    }
    finally {
        yield micropython.disconnect();
    }
});
const mv = (oldPath, newPath) => __awaiter(void 0, void 0, void 0, function* () {
    logVerbose('mv', oldPath, newPath);
    try {
        yield ensureConnectedDevice();
        yield micropython.rename(oldPath, newPath);
    }
    catch (e) {
        if (e instanceof main_1.ScriptExecutionError && e.message.includes('OSError: [Errno 2] ENOENT')) {
            logError(`mv: cannot rename '${oldPath}': No such file or directory`);
            return;
        }
        console.error('Error:', e);
        process.exit(1);
    }
    finally {
        yield micropython.disconnect();
    }
});
const run = (fileOrCommand) => __awaiter(void 0, void 0, void 0, function* () {
    logVerbose('run', fileOrCommand);
    const script = fs_1.default.existsSync(fileOrCommand) ? fs_1.default.readFileSync(fileOrCommand).toString() : fileOrCommand;
    logVerbose(script);
    try {
        yield ensureConnectedDevice();
        const output = yield micropython.runScript(script);
        console.log(output);
    }
    catch (e) {
        console.error('Error:', e);
        process.exit(1);
    }
    finally {
        yield micropython.disconnect();
    }
});
const edit = (filename) => __awaiter(void 0, void 0, void 0, function* () {
    logVerbose('edit', filename);
    const baseFilename = filename.replace(/^.*[\\\/]/, '');
    const tmpFilename = utils_node_1.getTmpFilename(baseFilename);
    try {
        yield ensureConnectedDevice();
        const output = yield micropython.getFile(filename);
        const hashBefore = crypto_1.default.createHash('sha256').update(output).digest('hex');
        // write to temp file and edit
        fs_1.default.writeFileSync(tmpFilename, output);
        const editorCmd = process.env.EDITOR || 'vim';
        child_process_1.execSync(`${editorCmd} ${tmpFilename}`, { stdio: 'inherit' });
        // read and compare
        const outputAfter = fs_1.default.readFileSync(tmpFilename);
        const hashAfter = crypto_1.default.createHash('sha256').update(outputAfter).digest('hex');
        // perhaps upload
        if (hashAfter !== hashBefore) {
            console.log(`File contents changed, uploading ${filename}...`);
            yield micropython.putFile(filename, buffer_1.Buffer.from(outputAfter));
        }
    }
    catch (e) {
        if (e instanceof main_1.ScriptExecutionError && e.message.includes('OSError: [Errno 2] ENOENT')) {
            logError(`cat: cannot access '${filename}': No such file or directory`);
            return;
        }
        else if (e instanceof main_1.ScriptExecutionError && e.message.includes('OSError: [Errno 21] EISDIR')) {
            logError(`cat: cannot read '${filename}' beacuse it is a directory`);
            return;
        }
        console.error('Error:', e);
        process.exit(1);
    }
    finally {
        yield micropython.disconnect();
    }
});
const reset = (cmdObj) => __awaiter(void 0, void 0, void 0, function* () {
    // logVerbose('reset')
    yield ensureConnectedDevice();
    yield micropython.reset({ softReset: !!cmdObj.soft }); // cannot await result because it's restarting and we loose the connection
    yield utils_1.delayMillis(500);
    process.exit(0);
});
const sync = (directory = './') => __awaiter(void 0, void 0, void 0, function* () {
    // console.log('sync', directory)
    try {
        yield ensureConnectedDevice();
        console.log('Getting file list from device...');
        yield micropython.gcCollect();
        const filesOnDevice = yield micropython.listFiles('/', { recursive: true, includeSha256: true });
        const filesOnDeviceByFilename = {};
        for (const entry of filesOnDevice.reverse()) {
            if (entry.filename === '/')
                continue;
            filesOnDeviceByFilename[entry.filename] = entry;
        }
        const getFilesInDir = (_dirname) => {
            const ret = [];
            for (const _filename of fs_1.default.readdirSync(_dirname)) {
                const fn = path.join(_dirname, _filename);
                const stat = fs_1.default.statSync(fn);
                if (stat.isFile()) {
                    const fileContent = fs_1.default.readFileSync(fn);
                    const localHash = crypto_1.default.createHash('sha256').update(fileContent).digest('hex');
                    ret.push({ filename: fn, isDir: false, sha256: localHash });
                }
                else if (stat.isDirectory()) {
                    ret.push({ filename: fn, isDir: true, sha256: null });
                    const subFiles = getFilesInDir(fn);
                    ret.push(...subFiles);
                }
            }
            return ret;
        };
        const filesLocal = getFilesInDir(directory);
        // console.log(filesLocal)
        const filesLocalHashes = {};
        for (const entry of filesLocal) {
            filesLocalHashes[entry.filename] = entry;
        }
        // console.log("Computing actions...")
        // Find files to delete (exist on device but not local)
        for (const fn in filesOnDeviceByFilename) {
            if (Object.prototype.hasOwnProperty.call(filesOnDeviceByFilename, fn)) {
                const fullFn = path.join(directory, fn);
                if (!filesLocalHashes[fullFn]) {
                    console.log(`delete ${fn} because not existing locally`);
                    yield micropython.remove(fn);
                }
            }
        }
        // Find files to upload or update
        for (const entry of filesLocal) {
            let targetFn = directory === './' ? entry.filename : entry.filename.substr(directory.length); // remove local path prefix
            if (!targetFn.startsWith('/'))
                targetFn = '/' + targetFn;
            // console.log(entry, targetFn)
            if (filesOnDeviceByFilename[targetFn]) {
                if (entry.isDir && filesOnDeviceByFilename[targetFn].isDir)
                    continue;
                const hashOnDevice = filesOnDeviceByFilename[targetFn].sha256;
                if (hashOnDevice !== entry.sha256) {
                    console.log(`upload ${targetFn}`);
                    yield micropython.remove(targetFn);
                    const data = buffer_1.Buffer.from(fs_1.default.readFileSync(entry.filename));
                    yield micropython.putFile(targetFn, data);
                }
            }
            else {
                if (entry.isDir) {
                    console.log(`create directory ${targetFn}`);
                    yield micropython.mkdir(targetFn);
                }
                else {
                    console.log(`upload ${entry.filename} -> ${targetFn}`);
                    const data = buffer_1.Buffer.from(fs_1.default.readFileSync(entry.filename));
                    yield micropython.putFile(targetFn, data);
                }
            }
        }
    }
    catch (e) {
        console.error('Error:', e);
        process.exit(1);
    }
    finally {
        yield micropython.disconnect();
    }
});
const sha256hash = (filename) => __awaiter(void 0, void 0, void 0, function* () {
    // logVerbose('sha256hash', filename)
    try {
        yield ensureConnectedDevice();
        const hash = yield micropython.getFileHash(filename);
        console.log(hash);
    }
    catch (e) {
        if (e instanceof main_1.ScriptExecutionError && e.message.includes('OSError: [Errno 2] ENOENT')) {
            logError(`sha256: cannot access '${filename}': No such file or directory`);
            return;
        }
        console.error('Error:', e);
        process.exit(1);
    }
    finally {
        yield micropython.disconnect();
    }
});
// Mount the device
const mountCommand = (targetPath) => __awaiter(void 0, void 0, void 0, function* () {
    console.log(`${CLR_FG_YELLOW}Mounting devices with FUSE is currently experimental! Please be careful, data might be corrupted. Reading files with binary data does not work, and maybe other things. -> https://github.com/metachris/micropython-ctl/issues/3${CLR_RESET}`);
    // Make sure FUSE dependencies are installed
    yield fuse_dependencies_1.checkAndInstall();
    // Connect to the device
    yield ensureConnectedDevice();
    // If device is disconnected, send SIGINT to self, which is handled by mount-device.ts (unmounts FUSE device)
    micropython.onclose = () => process.kill(process.pid, "SIGINT");
    // Mount now
    yield mount_device_1.mount({ micropythonDevice: micropython, mountPath: targetPath });
});
const repl = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield ensureConnectedDevice({ startWebserver: true });
        micropython.onclose = () => process.exit(0);
        micropython.onTerminalData = (data) => process.stdout.write(data);
        // Setup keyboard capture
        readline_1.default.emitKeypressEvents(process.stdin);
        process.stdin.setRawMode(true);
        process.stdin.on('keypress', (_str, key) => __awaiter(void 0, void 0, void 0, function* () {
            // Quit on Ctrl+K
            if (key.name === 'k' && key.ctrl)
                process.exit(0);
            // Send anything to the device, if connected
            if (micropython.isConnected() && micropython.isTerminalMode()) {
                micropython.sendData(key.sequence);
            }
        }));
        console.log('Exit REPL by pressing Ctrl+K');
    }
    catch (e) {
        console.log('Error:', e);
        yield micropython.disconnect();
    }
});
// Mount the device
const runTests = () => __awaiter(void 0, void 0, void 0, function* () {
    testsuite_1.run();
});
/**
 * Setup command line commands, using commander.js
 * https://github.com/tj/commander.js
 */
program.option('-t, --tty <device>', `Connect over serial interface (eg. /dev/tty.SLAB_USBtoUART)`);
program.option('-h, --host <host>', `Connect over network to hostname or IP of device`);
program.option('-p, --password <password>', `Password for network device`);
program.option('-s, --silent', `Hide unnecessary output`);
// Command: devices
program
    .command('devices')
    .description('List serial devices')
    .action(cmdListDevices);
// Command: repl
program
    .command('repl')
    .description('Open a REPL terminal')
    .action(repl);
// Command: run
program
    .command('run <fileOrCommand>')
    .description('Execute a Python file or command')
    .action(run);
// Command: info
program
    .command('info')
    .option('-j, --json', 'Output JSON')
    .description('Get information about the board (versions, unique id, space, memory)')
    .action(boardInfo);
// Command: ls
program
    .command('ls [directory]')
    .option('-r, --recursive', 'List recursively')
    .option('-j, --json', 'Output JSON')
    .option('--include-hash', 'Include sha256 hash of each file')
    .description('List files on a device')
    .action(listFilesOnDevice);
// Command: cat
program
    .command('cat <filename>')
    .description('Print content of a file on the device')
    .action(catFile);
// Command: get
program
    .command('get <file_or_dirname> [out_file_or_dirname]')
    .description(`Download a file or directory from the device. Download everything with 'get /'`)
    .action(get);
// Command: put
program
    .command('put <file_or_dirname> [dest_file_or_dirname]')
    .option('-c, --changed-only', 'Upload only if changed (useful for large files, but needs to calculate hash)')
    .description('Upload a file or directory onto the device')
    .action(put);
// Command: sync
program
    .command('sync [directory]')
    .description('Sync a local directory onto the device root (upload new/changes files, delete missing)')
    .action(sync);
// Command: edit
program
    .command('edit <filename>')
    .description('Edit a file, and if changed upload afterwards')
    .action(edit);
// Command: mkdir
program
    .command('mkdir <name>')
    .description('Create a directory')
    .action(mkdir);
// Command: rm [-r]
program
    .command('rm <path>')
    .option('-r, --recursive', 'Delete recursively')
    .description('Delete a file or directory')
    .action(rm);
// Command: mv
program
    .command('mv <oldPath> <newPath>')
    .description('Rename a file or directory')
    .action(mv);
// Command: filehash
program
    .command('sha256 <filename>')
    .description('Get the SHA256 hash of a file')
    .action(sha256hash);
// Command: reset
program
    .command('reset')
    .option('--soft', 'soft-reset instead of hard-reset')
    .description('Reset the MicroPython device')
    .action(reset);
// Command: mount
program
    .command('mount [targetPath]')
    .description('Mount a MicroPython device (over serial or network)')
    .action(mountCommand);
// Command: run-tests
program
    .command('run-tests')
    .description('Run micropython-ctl tests on a device')
    .action(runTests);
// Command: version
program
    .command('version')
    .description('Print the version of mctl')
    .action(() => {
    console.log(`v${pjson.version}`);
});
program.addHelpText('after', `\nhttps://github.com/metachris/micropython-ctl v${pjson.version}`);
(() => __awaiter(void 0, void 0, void 0, function* () {
    yield program.parseAsync(process.argv);
    // const options = program.parse(process.argv);
    // console.log(options.tty)
    // await ensureConnectedDevice()
    // const data = Buffer.from(fs.readFileSync('boot.py'))
    // const isSame = await micropython.isFileTheSame('boot.py', data)
    // console.log('isSame', isSame)
    // await micropython.disconnect()
}))();
//# sourceMappingURL=index.js.map